#!/usr/bin/perl

use lib 'lib';
use Jemplate 0.11;
use Getopt::Long;

sub usage {
    warn <<'...';

Usage:
    jemplate -c|-l [options] template-list

Example:
    jemplate --compile --runtime templates/* > jemplate.js
        Compile all the template files in the templates/ directory and
        put the output in jemplate.js. Also include the Jemplate runtime
        code in the output.

template-list:
    The template-list is the list of template files that will be
    compiled. If something in the list is a file, then the template name
    will be just the filename. If it is a directory, then all the files
    under that directory will be found, and the relative paths to those
    files will be the template name.

    So 'template/foo/bar.tt2' will be named 'bar.tt2', but 'template/'
    will find a template named 'foo/bar.tt2'.

    It is important to know what Jemplate thinks the template name will
    be when you are writing templates or code that refers to other
    templates. Use the --list option to check this.

Commands:

    -c, --compile
        The --compile flag tells Jemplate to actually compile templates.
        The output is written to STDOUT.

    -l, --list
        Just list the template names that Jemplate would use from the
        template-list.

Options:
    -r, --runtime
        Include the Jemplate runtime code in the compilation output. (So
        you can have all your Jemplate related code in one file.

    -e, --exec (--noexec)
        Allow the execution of raw Javascript. This option is on by
        default. Use --noexec to disallow it.

...
    exit;
}

{
    my $javascript = 1;
    my $compile = 0;

    GetOptions(
        "compile|c"      => \$compile,
        "javascript|js!" => \$javascript,
        "list|l"         => \$list,
        "help"           => \&usage,
    ) || usage();

    my $jemplate = Jemplate->new(EVAL_JAVASCRIPT => $javascript);

    my $templates = make_file_list(@ARGV);

    if ($list) {
        foreach (@$templates) { print $_->{full} . ' => ' . $_->{short} . "\n"; }
    }
    elsif ($compile) {
        usage() unless @$templates;

        print $jemplate->_preamble;

        foreach my $template (@$templates) {
            my $content = slurp($template->{full});
            if ($content) {
                print $jemplate->compile_template_content($content, $template->{short});
            }
        }
    }
    else {
        usage();
    }
};


sub slurp {
    my $filename = shift;
    open(F, '<', $filename) or die "Can't open '$filepath' for input:\n$!";
    my $contents = do {local $/; <F>};
    close(F);
    return $contents;
}

sub recurse_dir {
    use File::Find::Rule;

    my $dir = shift;
    my @files;
    foreach ( File::Find::Rule->file->in( $dir ) ) {
        # don't include .hidden files
        unless ($_ =~ '\/\.') { push(@files, $_); }
    }
    return @files;
}

sub make_file_list {
    my @args = @_;

    my @list;

    foreach my $arg (@args) {
        unless (-e $arg) { next; } # file exists
        unless (-s $arg) { next; } # file size > 0

        if (-d $arg) {
            foreach my $full ( recurse_dir($arg) ) {
                $full =~ /$arg(|\/)(.*)/;
                my $short = $2;
                push(@list, {full=>$full, short=>$short} );
            }
        }
        else {
            my $full = $arg;
            my $short = $full;
            $short =~ s/.*[\/\\]//;
            push(@list, {full=>$arg, short=>$short} );
        }
    }

    return \@list;
}
